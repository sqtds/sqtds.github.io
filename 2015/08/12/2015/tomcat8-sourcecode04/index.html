<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>tomcat8源码阅读(四)--启动三 | 蜻蜓点水</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一，回顾上文介绍了Server的启动过程，但是没有详细介绍Container和Connector的详细启动流程，下面我将介绍Container的启动流程。
二，Container的init下面我看看Container的继承结构：Engine，Host，Context，Wrapper都属于Container。下面，我们根据server.xml的默认配置结构来看看。
&amp;lt;Engine name=&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="tomcat8源码阅读(四)--启动三">
<meta property="og:url" content="http://sqtds.github.io/2015/08/12/2015/tomcat8-sourcecode04/index.html">
<meta property="og:site_name" content="蜻蜓点水">
<meta property="og:description" content="一，回顾上文介绍了Server的启动过程，但是没有详细介绍Container和Connector的详细启动流程，下面我将介绍Container的启动流程。
二，Container的init下面我看看Container的继承结构：Engine，Host，Context，Wrapper都属于Container。下面，我们根据server.xml的默认配置结构来看看。
&amp;lt;Engine name=&quot;">
<meta property="og:image" content="/img/2015/container.png">
<meta property="og:image" content="/img/2015/tomcat8-catalian-start1.png">
<meta property="og:image" content="/img/2015/tomcat8-catalian-start2.png">
<meta property="og:image" content="/img/2015/tomcat8-catalian-start3.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tomcat8源码阅读(四)--启动三">
<meta name="twitter:description" content="一，回顾上文介绍了Server的启动过程，但是没有详细介绍Container和Connector的详细启动流程，下面我将介绍Container的启动流程。
二，Container的init下面我看看Container的继承结构：Engine，Host，Context，Wrapper都属于Container。下面，我们根据server.xml的默认配置结构来看看。
&amp;lt;Engine name=&quot;">
  
    <link rel="alternative" href="/atom.xml" title="蜻蜓点水" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1bd1f966e3148e2b59e4b159067ad372";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="/img/photo.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">sqtds</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/sqtds" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="/sqtds@163.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 16.67px;">android</a><a href="/tags/antlr4/" style="font-size: 18.33px;">antlr4</a><a href="/tags/hadoop/" style="font-size: 11.67px;">hadoop</a><a href="/tags/impala/" style="font-size: 10px;">impala</a><a href="/tags/java/" style="font-size: 11.67px;">java</a><a href="/tags/java核心系列/" style="font-size: 20px;">java核心系列</a><a href="/tags/java源码阅读/" style="font-size: 13.33px;">java源码阅读</a><a href="/tags/linux/" style="font-size: 15px;">linux</a><a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a><a href="/tags/mondrian/" style="font-size: 18.33px;">mondrian</a><a href="/tags/netty/" style="font-size: 10px;">netty</a><a href="/tags/nosql/" style="font-size: 11.67px;">nosql</a><a href="/tags/spring/" style="font-size: 15px;">spring</a><a href="/tags/tomcat/" style="font-size: 16.67px;">tomcat</a><a href="/tags/分布式/" style="font-size: 10px;">分布式</a><a href="/tags/异常/" style="font-size: 10px;">异常</a><a href="/tags/性能/" style="font-size: 10px;">性能</a><a href="/tags/数据库/" style="font-size: 15px;">数据库</a><a href="/tags/缓存/" style="font-size: 10px;">缓存</a><a href="/tags/计算机原理/" style="font-size: 16.67px;">计算机原理</a><a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">sqtds</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">sqtds</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/sqtds" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="/sqtds@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2015/tomcat8-sourcecode04" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/12/2015/tomcat8-sourcecode04/" class="article-date">
  	<time datetime="2015-08-12T13:40:47.000Z" itemprop="datePublished">8月 12 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      tomcat8源码阅读(四)--启动三
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tomcat/">tomcat</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一，回顾">一，回顾</h2><p>上文介绍了Server的启动过程，但是没有详细介绍Container和Connector的详细启动流程，下面我将介绍Container的启动流程。</p>
<h2 id="二，Container的init">二，Container的init</h2><p>下面我看看Container的继承结构：<br><img src="/img/2015/container.png" alt=""><br>Engine，Host，Context，Wrapper都属于Container。下面，我们根据server.xml的默认配置结构来看看。</p>
<pre><code><span class="tag">&lt;<span class="title">Engine</span> <span class="attribute">name</span>=<span class="value">"Catalina"</span> <span class="attribute">defaultHost</span>=<span class="value">"localhost"</span>&gt;</span>
  <span class="comment">&lt;!--
  &lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt;
  --&gt;</span> 
   //LockOutRealm防止暴力破解
  <span class="tag">&lt;<span class="title">Realm</span> <span class="attribute">className</span>=<span class="value">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">Realm</span> <span class="attribute">className</span>=<span class="value">"org.apache.catalina.realm.UserDatabaseRealm"</span>
           <span class="attribute">resourceName</span>=<span class="value">"UserDatabase"</span>/&gt;</span>
  <span class="tag">&lt;/<span class="title">Realm</span>&gt;</span>

  <span class="tag">&lt;<span class="title">Host</span> <span class="attribute">name</span>=<span class="value">"localhost"</span>  <span class="attribute">appBase</span>=<span class="value">"webapps"</span>
        <span class="attribute">unpackWARs</span>=<span class="value">"true"</span> <span class="attribute">autoDeploy</span>=<span class="value">"true"</span>&gt;</span>

    <span class="tag">&lt;<span class="title">Valve</span> <span class="attribute">className</span>=<span class="value">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attribute">directory</span>=<span class="value">"logs"</span>
           <span class="attribute">prefix</span>=<span class="value">"localhost_access_log"</span> <span class="attribute">suffix</span>=<span class="value">".txt"</span>
           <span class="attribute">pattern</span>=<span class="value">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span>

  <span class="tag">&lt;/<span class="title">Host</span>&gt;</span>
<span class="tag">&lt;/<span class="title">Engine</span>&gt;</span>
</code></pre><p>其中有Realm，这个是TOMCAT的安全域，我们暂时不关心，看其他的几个。</p>
<h3 id="2-1_Engine的initInternal">2.1 Engine的initInternal</h3><pre><code> <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>{
    <span class="comment">//获取一个默认的安全域</span>
    getRealm();
    <span class="keyword">super</span>.initInternal();
}
</code></pre><p>方法比较简单，我们关注super.initInternal()方法：</p>
<h3 id="2-2_ContainerBase的initInternal">2.2 ContainerBase的initInternal</h3><p>ContainerBase主要是创建一个startStopExecutor线程池用来启动停止子节点。</p>
<pre><code>ContainerBase
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>{
    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();
    <span class="comment">//创建线程池 </span>
    startStopExecutor = <span class="keyword">new</span> ThreadPoolExecutor(
            getStartStopThreadsInternal(),
            getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,
            startStopQueue,
            <span class="keyword">new</span> StartStopThreadFactory(getName() + <span class="string">"-startStop-"</span>));
    startStopExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);
    <span class="keyword">super</span>.initInternal();
}        
</code></pre><h3 id="2-3_StandardHost的initInternal">2.3 StandardHost的initInternal</h3><pre><code><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>{
    <span class="comment">//设置异常处理valve</span>
    String errorValve = getErrorReportValveClass();
    <span class="keyword">super</span>.startInternal();
}
</code></pre><h3 id="2-4_StandardContext的initInternal">2.4 StandardContext的initInternal</h3><pre><code><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>{
    <span class="keyword">super</span>.initInternal();

    <span class="comment">//注册命名服务</span>
    <span class="keyword">if</span> (namingResources != <span class="keyword">null</span>) {
        namingResources.init();
    }
    <span class="comment">//启动</span>
    <span class="keyword">if</span> (resources != <span class="keyword">null</span>) {
        resources.start();
    }

    <span class="comment">// Send j2ee.object.created notification</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>) {
        Notification notification = <span class="keyword">new</span> Notification(<span class="string">"j2ee.object.created"</span>,
                <span class="keyword">this</span>.getObjectName(), sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }
}
</code></pre><h3 id="2-5_StandardWrapper的initInternal">2.5 StandardWrapper的initInternal</h3><p>StandardWrapper的initInternal继承的父类ContainerBase的initInternal。</p>
<p>这样，初始化工作就告一段落了，下面，我们看start方法。</p>
<h2 id="三，Container的start">三，Container的start</h2><p>上文中我们知道，Container的start最终会调用自己的startInternal方法，下面我们看具体实现。</p>
<h3 id="3-1_StandardEngine的startInternal">3.1 StandardEngine的startInternal</h3><pre><code>StandardEngine
<span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>{
    <span class="keyword">super</span>.startInternal();
}
</code></pre><p>StandardEngine调用了父类ContainerBase的startInternal方法。</p>
<h3 id="3-2_ContainerBase的startInternal">3.2 ContainerBase的startInternal</h3><pre><code>ContainerBase
<span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> startInternal() <span class="keyword">throws</span> LifecycleException {
    logger = <span class="keyword">null</span>;
    getLogger();
    <span class="comment">//获取并启动集群</span>
    Cluster cluster = getClusterInternal();
    <span class="keyword">if</span> (cluster <span class="keyword">instanceof</span> Lifecycle) {
        ((Lifecycle) cluster).start();
    }
    <span class="comment">//获取并启动安全域</span>
    Realm realm = getRealmInternal();
    <span class="keyword">if</span> (realm <span class="keyword">instanceof</span> Lifecycle) {
        ((Lifecycle) realm).start();
    }

    <span class="comment">//使用线程池启动子容器</span>
    Container children[] = findChildren();
    List&lt;Future&lt;Void&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();
    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) {
        results.<span class="built_in">add</span>(startStopExecutor.submit(<span class="keyword">new</span> StartChild(children[i])));
    }
    <span class="comment">//异步获取启动结果</span>
    <span class="built_in">boolean</span> fail = <span class="keyword">false</span>;
    <span class="keyword">for</span> (Future&lt;Void&gt; result : results) {
        <span class="keyword">try</span> {
            result.<span class="built_in">get</span>();
        } <span class="keyword">catch</span> (Exception e) {
            <span class="built_in">log</span>.error(sm.getString(<span class="string">"containerBase.threadedStartFailed"</span>), e);
            fail = <span class="keyword">true</span>;
        }

    }
    <span class="keyword">if</span> (fail) {
        <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(
                sm.getString(<span class="string">"containerBase.threadedStartFailed"</span>));
    }

    <span class="comment">// 启动pipeline中的Valves</span>
    <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle)
        ((Lifecycle) pipeline).start();

    setState(LifecycleState.STARTING);

    <span class="comment">//启动后台线程，定期检查session超时</span>
    threadStart();
}
</code></pre><p>就这样，ContainerBase会将它的子容器用线程池启动起来。</p>
<h3 id="3-3_StandardHost的startInternal">3.3 StandardHost的startInternal</h3><pre><code>StandardHost
<span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>{
    String errorValve = getErrorReportValveClass();
    <span class="keyword">super</span>.startInternal();
}
</code></pre><p>啥也没做，继续调用父类的startInternal方法。</p>
<h3 id="3-4_StandardContext的startInternal">3.4 StandardContext的startInternal</h3><pre><code>StandardContext
<span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> startInternal() <span class="keyword">throws</span> LifecycleException {
    <span class="comment">// Send j2ee.state.starting notification</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>) {
        Notification notification = <span class="keyword">new</span> Notification(<span class="string">"j2ee.state.starting"</span>,
                <span class="keyword">this</span>.getObjectName(), sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }

    setConfigured(<span class="keyword">false</span>);
    <span class="built_in">boolean</span> ok = <span class="keyword">true</span>;

    <span class="comment">// Currently this is effectively a NO-OP but needs to be called to</span>
    <span class="comment">// ensure the NamingResources follows the correct lifecycle</span>
    <span class="keyword">if</span> (namingResources != <span class="keyword">null</span>) {
        namingResources.start();
    }

    <span class="comment">// Add missing components as necessary</span>
    <span class="keyword">if</span> (getResources() == <span class="keyword">null</span>) {   <span class="comment">// (1) Required by Loader</span>
        <span class="keyword">if</span> (<span class="built_in">log</span>.isDebugEnabled())
            <span class="built_in">log</span>.debug(<span class="string">"Configuring default Resources"</span>);

        <span class="keyword">try</span> {
            setResources(<span class="keyword">new</span> StandardRoot(<span class="keyword">this</span>));
        } <span class="keyword">catch</span> (IllegalArgumentException e) {
            <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.resourcesInit"</span>), e);
            ok = <span class="keyword">false</span>;
        }
    }
    <span class="keyword">if</span> (ok) {
        resourcesStart();
    }

    <span class="keyword">if</span> (getLoader() == <span class="keyword">null</span>) {
        WebappLoader webappLoader = <span class="keyword">new</span> WebappLoader(getParentClassLoader());
        webappLoader.setDelegate(getDelegate());
        setLoader(webappLoader);
    }

    <span class="comment">// Initialize character set mapper</span>
    getCharsetMapper();

    <span class="comment">// Post work directory</span>
    postWorkDirectory();

    <span class="comment">// Validate required extensions</span>
    <span class="built_in">boolean</span> dependencyCheck = <span class="keyword">true</span>;
    <span class="keyword">try</span> {
        dependencyCheck = ExtensionValidator.validateApplication
            (getResources(), <span class="keyword">this</span>);
    } <span class="keyword">catch</span> (IOException ioe) {
        <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.extensionValidationError"</span>), ioe);
        dependencyCheck = <span class="keyword">false</span>;
    }

    <span class="keyword">if</span> (!dependencyCheck) {
        <span class="comment">// do not make application available if depency check fails</span>
        ok = <span class="keyword">false</span>;
    }

    <span class="comment">// Reading the "catalina.useNaming" environment variable</span>
    <span class="keyword">String</span> useNamingProperty = System.getProperty(<span class="string">"catalina.useNaming"</span>);
    <span class="keyword">if</span> ((useNamingProperty != <span class="keyword">null</span>)
        &amp;&amp; (useNamingProperty.equals(<span class="string">"false"</span>))) {
        useNaming = <span class="keyword">false</span>;
    }

    <span class="keyword">if</span> (ok &amp;&amp; isUseNaming()) {
        <span class="keyword">if</span> (getNamingContextListener() == <span class="keyword">null</span>) {
            NamingContextListener ncl = <span class="keyword">new</span> NamingContextListener();
            ncl.setName(getNamingContextName());
            ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite());
            addLifecycleListener(ncl);
            setNamingContextListener(ncl);
        }
    }

    <span class="comment">// Standard container startup</span>
    <span class="keyword">if</span> (<span class="built_in">log</span>.isDebugEnabled())
        <span class="built_in">log</span>.debug(<span class="string">"Processing standard container startup"</span>);


    <span class="comment">// Binding thread</span>
    ClassLoader oldCCL = bindThread();

    <span class="keyword">try</span> {
        <span class="keyword">if</span> (ok) {
            <span class="comment">// Start our subordinate components, if any</span>
            Loader loader = getLoader();
            <span class="keyword">if</span> (loader <span class="keyword">instanceof</span> Lifecycle) {
                ((Lifecycle) loader).start();
            }

            <span class="comment">// since the loader just started, the webapp classloader is now</span>
            <span class="comment">// created.</span>
            setClassLoaderProperty(<span class="string">"clearReferencesStatic"</span>,
                    getClearReferencesStatic());
            setClassLoaderProperty(<span class="string">"clearReferencesStopThreads"</span>,
                    getClearReferencesStopThreads());
            setClassLoaderProperty(<span class="string">"clearReferencesStopTimerThreads"</span>,
                    getClearReferencesStopTimerThreads());
            setClassLoaderProperty(<span class="string">"clearReferencesHttpClientKeepAliveThread"</span>,
                    getClearReferencesHttpClientKeepAliveThread());

            <span class="comment">// By calling unbindThread and bindThread in a row, we setup the</span>
            <span class="comment">// current Thread CCL to be the webapp classloader</span>
            unbindThread(oldCCL);
            oldCCL = bindThread();

            <span class="comment">// Initialize logger again. Other components might have used it</span>
            <span class="comment">// too early, so it should be reset.</span>
            logger = <span class="keyword">null</span>;
            getLogger();

            Cluster cluster = getClusterInternal();
            <span class="keyword">if</span> (cluster <span class="keyword">instanceof</span> Lifecycle) {
                ((Lifecycle) cluster).start();
            }
            Realm realm = getRealmInternal();
            <span class="keyword">if</span> (realm <span class="keyword">instanceof</span> Lifecycle) {
                ((Lifecycle) realm).start();
            }

            <span class="comment">// Notify our interested LifecycleListeners</span>
            fireLifecycleEvent(Lifecycle.CONFIGURE_START_EVENT, <span class="keyword">null</span>);

            <span class="comment">// Start our child containers, if not already started</span>
            <span class="keyword">for</span> (Container child : findChildren()) {
                <span class="keyword">if</span> (!child.getState().isAvailable()) {
                    child.start();
                }
            }

            <span class="comment">// Start the Valves in our pipeline (including the basic),</span>
            <span class="comment">// if any</span>
            <span class="keyword">if</span> (pipeline <span class="keyword">instanceof</span> Lifecycle) {
                ((Lifecycle) pipeline).start();
            }

            <span class="comment">// Acquire clustered manager</span>
            Manager contextManager = <span class="keyword">null</span>;
            Manager manager = getManager();
            <span class="keyword">if</span> (manager == <span class="keyword">null</span>) {
                <span class="keyword">if</span> (<span class="built_in">log</span>.isDebugEnabled()) {
                    <span class="built_in">log</span>.debug(sm.getString(<span class="string">"standardContext.cluster.noManager"</span>,
                            Boolean.valueOf((getCluster() != <span class="keyword">null</span>)),
                            Boolean.valueOf(distributable)));
                }
                <span class="keyword">if</span> ( (getCluster() != <span class="keyword">null</span>) &amp;&amp; distributable) {
                    <span class="keyword">try</span> {
                        contextManager = getCluster().createManager(getName());
                    } <span class="keyword">catch</span> (Exception ex) {
                        <span class="built_in">log</span>.error(<span class="string">"standardContext.clusterFail"</span>, ex);
                        ok = <span class="keyword">false</span>;
                    }
                } <span class="keyword">else</span> {
                    contextManager = <span class="keyword">new</span> StandardManager();
                }
            }

            <span class="comment">// Configure default manager if none was specified</span>
            <span class="keyword">if</span> (contextManager != <span class="keyword">null</span>) {
                <span class="keyword">if</span> (<span class="built_in">log</span>.isDebugEnabled()) {
                    <span class="built_in">log</span>.debug(sm.getString(<span class="string">"standardContext.manager"</span>,
                            contextManager.getClass().getName()));
                }
                setManager(contextManager);
            }

            <span class="keyword">if</span> (manager!=<span class="keyword">null</span> &amp;&amp; (getCluster() != <span class="keyword">null</span>) &amp;&amp; distributable) {
                <span class="comment">//let the cluster know that there is a context that is distributable</span>
                <span class="comment">//and that it has its own manager</span>
                getCluster().registerManager(manager);
            }
        }

        <span class="keyword">if</span> (!getConfigured()) {
            <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.configurationFail"</span>));
            ok = <span class="keyword">false</span>;
        }

        <span class="comment">// We put the resources into the servlet context</span>
        <span class="keyword">if</span> (ok)
            getServletContext().setAttribute
                (Globals.RESOURCES_ATTR, getResources());

        <span class="keyword">if</span> (ok ) {
            <span class="keyword">if</span> (getInstanceManager() == <span class="keyword">null</span>) {
                javax.naming.Context context = <span class="keyword">null</span>;
                <span class="keyword">if</span> (isUseNaming() &amp;&amp; getNamingContextListener() != <span class="keyword">null</span>) {
                    context = getNamingContextListener().getEnvContext();
                }
                Map&lt;<span class="keyword">String</span>, Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt; injectionMap = buildInjectionMap(
                        getIgnoreAnnotations() ? <span class="keyword">new</span> NamingResourcesImpl(): getNamingResources());
                setInstanceManager(<span class="keyword">new</span> DefaultInstanceManager(context,
                        injectionMap, <span class="keyword">this</span>, <span class="keyword">this</span>.getClass().getClassLoader()));
                getServletContext().setAttribute(
                        InstanceManager.class.getName(), getInstanceManager());
            }
        }

        <span class="comment">// Create context attributes that will be required</span>
        <span class="keyword">if</span> (ok) {
            getServletContext().setAttribute(
                    JarScanner.class.getName(), getJarScanner());
        }

        <span class="comment">// Set up the context init params</span>
        mergeParameters();

        <span class="comment">// Call ServletContainerInitializers</span>
        <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :
            initializers.entrySet()) {
            <span class="keyword">try</span> {
                entry.getKey().onStartup(entry.getValue(),
                        getServletContext());
            } <span class="keyword">catch</span> (ServletException e) {
                <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.sciFail"</span>), e);
                ok = <span class="keyword">false</span>;
                <span class="keyword">break</span>;
            }
        }

        <span class="comment">// Configure and call application event listeners</span>
        <span class="keyword">if</span> (ok) {
            <span class="keyword">if</span> (!listenerStart()) {
                <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.listenerFail"</span>));
                ok = <span class="keyword">false</span>;
            }
        }

        <span class="comment">// Check constraints for uncovered HTTP methods</span>
        <span class="comment">// Needs to be after SCIs and listeners as they may programatically</span>
        <span class="comment">// change constraints</span>
        <span class="keyword">if</span> (ok) {
            checkConstraintsForUncoveredMethods(findConstraints());
        }

        <span class="keyword">try</span> {
            <span class="comment">// Start manager</span>
            Manager manager = getManager();
            <span class="keyword">if</span> (manager <span class="keyword">instanceof</span> Lifecycle) {
                ((Lifecycle) manager).start();
            }
        } <span class="keyword">catch</span>(Exception e) {
            <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.managerFail"</span>), e);
            ok = <span class="keyword">false</span>;
        }

        <span class="comment">// Configure and call application filters</span>
        <span class="keyword">if</span> (ok) {
            <span class="keyword">if</span> (!filterStart()) {
                <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.filterFail"</span>));
                ok = <span class="keyword">false</span>;
            }
        }

        <span class="comment">// Load and initialize all "load on startup" servlets</span>
        <span class="keyword">if</span> (ok) {
            <span class="keyword">if</span> (!loadOnStartup(findChildren())){
                <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.servletFail"</span>));
                ok = <span class="keyword">false</span>;
            }
        }

        <span class="comment">// Start ContainerBackgroundProcessor thread</span>
        <span class="keyword">super</span>.threadStart();
    } <span class="keyword">finally</span> {
        <span class="comment">// Unbinding thread</span>
        unbindThread(oldCCL);
    }

    <span class="comment">// Set available status depending upon startup success</span>
    <span class="keyword">if</span> (ok) {
        <span class="keyword">if</span> (<span class="built_in">log</span>.isDebugEnabled())
            <span class="built_in">log</span>.debug(<span class="string">"Starting completed"</span>);
    } <span class="keyword">else</span> {
        <span class="built_in">log</span>.error(sm.getString(<span class="string">"standardContext.startFailed"</span>, getName()));
    }

    startTime=System.currentTimeMillis();

    <span class="comment">// Send j2ee.state.running notification</span>
    <span class="keyword">if</span> (ok &amp;&amp; (<span class="keyword">this</span>.getObjectName() != <span class="keyword">null</span>)) {
        Notification notification =
            <span class="keyword">new</span> Notification(<span class="string">"j2ee.state.running"</span>, <span class="keyword">this</span>.getObjectName(),
                             sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }

    <span class="comment">// The WebResources implementation caches references to JAR files. On</span>
    <span class="comment">// some platforms these references may lock the JAR files. Since web</span>
    <span class="comment">// application start is likely to have read from lots of JARs, trigger</span>
    <span class="comment">// a clean-up now.</span>
    getResources().gc();

    <span class="comment">// Reinitializing if something went wrong</span>
    <span class="keyword">if</span> (!ok) {
        setState(LifecycleState.FAILED);
    } <span class="keyword">else</span> {
        setState(LifecycleState.STARTING);
    }
}
</code></pre><p>上面代码有点长，主要是做了资源的设置，类加载器的设置，session管理的设置等。当然也启动了pipeline。但是有一点我们需要注意的是，子容器并不是在pipeline的StandardContextValve中传递执行的。那么是在哪里呢？其实就在StandardContext中的startInternal执行的。为什么要这样设计呢？我们发现，这是由于servlet在xml中的顺序决定了启动顺序。<br>接下来有人会不会有另一个疑惑，要是我在server.xml没有配置context，只是放在了webapps目录下面，那么这个context是如何加载的呢？接下来，我就讲讲这个。</p>
<h2 id="四，Context调用时机">四，Context调用时机</h2><p>context可以有2种表现形式，一种是直接写在server.xml文件中，另一种是放在tomcat的webapps目录下。<br>第一种形式已经在前面介绍过了，下面，我们介绍第二中形式。</p>
<h3 id="4-1_Host启动触发监听事件">4.1 Host启动触发监听事件</h3><p>大家还记得否，当我们每次调用LifecycleBase的start方法时，都会调用下面这句：</p>
<blockquote>
<p>setStateInternal(LifecycleState.STARTED, null, false);</p>
</blockquote>
<p>那这句话做了什么工作呢？我们看其源码实现：</p>
<pre><code>LifecycleBase
private synchronized void <span class="built_in">set</span>StateInternal(LifecycleState <span class="keyword">state</span>,
        Object data, boolean check) throws LifecycleException {

    ...//检查状态
    this.<span class="keyword">state</span> = <span class="keyword">state</span>;
    String lifecycleEvent = <span class="keyword">state</span>.getLifecycleEvent();
    if (lifecycleEvent != null) {
        fireLifecycleEvent(lifecycleEvent, data);
    }
}

protected void fireLifecycleEvent(String type, Object data) {
    LifecycleEvent event = new LifecycleEvent(this, type, data);
    LifecycleListener interested[] = listeners;
    <span class="keyword">for</span> (int i = <span class="number">0</span>; i <span class="variable">&lt; interested.length; i++) {
        interested[i].lifecycleEvent(event);
    }
}</span>
</code></pre><p>我们看到，这里会触犯监听器执行感兴趣的事件。那在StandardHost中有哪些监听器呢？</p>
<h3 id="4-2_创建Host监听">4.2 创建Host监听</h3><p>我们要跳到Digester那一块了，大家还记得Digester那块嘛？在Catalina的createStartDigester() 方法中，我们看到下面一句话：</p>
<blockquote>
<p>digester.addRuleSet(new HostRuleSet(“Server/Service/Engine/“));</p>
</blockquote>
<p>那这句话内部干了什么呢？我们看其实现：</p>
<pre><code><span class="type">Digester</span>
public void addRuleSet(<span class="type">RuleSet</span> ruleSet) {

    <span class="type">String</span> oldNamespaceURI = getRuleNamespaceURI();
    <span class="type">String</span> newNamespaceURI = ruleSet.getNamespaceURI();

    setRuleNamespaceURI(newNamespaceURI);
    ruleSet.addRuleInstances(this); <span class="comment">//我们重点看这句</span>
    setRuleNamespaceURI(oldNamespaceURI);
}

<span class="type">HostRuleSet</span>
public void addRuleInstances(<span class="type">Digester</span> digester) {

    digester.addObjectCreate(<span class="keyword">prefix</span> + <span class="string">"Host"</span>,
                             <span class="string">"org.apache.catalina.core.StandardHost"</span>,
                             <span class="string">"className"</span>);
    digester.addSetProperties(<span class="keyword">prefix</span> + <span class="string">"Host"</span>);
    digester.addRule(<span class="keyword">prefix</span> + <span class="string">"Host"</span>,
                     <span class="keyword">new</span> <span class="type">CopyParentClassLoaderRule</span>());

    <span class="comment">//这里创建了HostConfig监听器</span>
    digester.addRule(<span class="keyword">prefix</span> + <span class="string">"Host"</span>,
                     <span class="keyword">new</span> <span class="type">LifecycleListenerRule</span>
                     (<span class="string">"org.apache.catalina.startup.HostConfig"</span>,
                      <span class="string">"hostConfigClass"</span>));
    digester.addSetNext(<span class="keyword">prefix</span> + <span class="string">"Host"</span>,
                        <span class="string">"addChild"</span>,
                        <span class="string">"org.apache.catalina.Container"</span>);

    digester.addCallMethod(<span class="keyword">prefix</span> + <span class="string">"Host/Alias"</span>,
                           <span class="string">"addAlias"</span>, <span class="number">0</span>);

    <span class="comment">//Cluster configuration start</span>
    digester.addObjectCreate(<span class="keyword">prefix</span> + <span class="string">"Host/Cluster"</span>,
                             null, <span class="comment">// MUST be specified in the element</span>
                             <span class="string">"className"</span>);
    digester.addSetProperties(<span class="keyword">prefix</span> + <span class="string">"Host/Cluster"</span>);
    digester.addSetNext(<span class="keyword">prefix</span> + <span class="string">"Host/Cluster"</span>,
                        <span class="string">"setCluster"</span>,
                        <span class="string">"org.apache.catalina.Cluster"</span>);
    <span class="comment">//Cluster configuration end</span>

    digester.addObjectCreate(<span class="keyword">prefix</span> + <span class="string">"Host/Listener"</span>,
                             null, <span class="comment">// MUST be specified in the element</span>
                             <span class="string">"className"</span>);
    digester.addSetProperties(<span class="keyword">prefix</span> + <span class="string">"Host/Listener"</span>);
    digester.addSetNext(<span class="keyword">prefix</span> + <span class="string">"Host/Listener"</span>,
                        <span class="string">"addLifecycleListener"</span>,
                        <span class="string">"org.apache.catalina.LifecycleListener"</span>);

    digester.addRuleSet(<span class="keyword">new</span> <span class="type">RealmRuleSet</span>(<span class="keyword">prefix</span> + <span class="string">"Host/"</span>));

    digester.addObjectCreate(<span class="keyword">prefix</span> + <span class="string">"Host/Valve"</span>,
                             null, <span class="comment">// MUST be specified in the element</span>
                             <span class="string">"className"</span>);
    digester.addSetProperties(<span class="keyword">prefix</span> + <span class="string">"Host/Valve"</span>);
    digester.addSetNext(<span class="keyword">prefix</span> + <span class="string">"Host/Valve"</span>,
                        <span class="string">"addValve"</span>,
                        <span class="string">"org.apache.catalina.Valve"</span>);

}
</code></pre><p>好，在这里我们看到了HostConfig被添加到监听器里面了。那这个HostConfig干了什么呢？我们接下来继续看。</p>
<h3 id="4-3_触发HostConfig调用start方法">4.3 触发HostConfig调用start方法</h3><p>我们看他的lifecycleEvent方法实现：</p>
<pre><code><span class="function">HostConfig
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent <span class="keyword">event</span>)</span> </span>{

    <span class="comment">// Identify the host we are associated with</span>
    <span class="keyword">try</span> {
        host = (Host) <span class="keyword">event</span>.getLifecycle();
        <span class="keyword">if</span> (host instanceof StandardHost) {
            setCopyXML(((StandardHost) host).isCopyXML());
            setDeployXML(((StandardHost) host).isDeployXML());
            setUnpackWARs(((StandardHost) host).isUnpackWARs());
            setContextClass(((StandardHost) host).getContextClass());
        }
    } <span class="keyword">catch</span> (ClassCastException e) {
        log.error(sm.getString(<span class="string">"hostConfig.cce"</span>, <span class="keyword">event</span>.getLifecycle()), e);
        <span class="keyword">return</span>;
    }

    <span class="comment">// Process the event that has occurred</span>
    <span class="keyword">if</span> (<span class="keyword">event</span>.getType().equals(Lifecycle.PERIODIC_EVENT)) {
        check();
    } <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(<span class="keyword">event</span>.getType()</span>.<span class="title">equals</span><span class="params">(Lifecycle.START_EVENT)</span>) </span>{
        start();
    } <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(<span class="keyword">event</span>.getType()</span>.<span class="title">equals</span><span class="params">(Lifecycle.STOP_EVENT)</span>) </span>{
        stop();
    }
}
</code></pre><p>我们看到，当传递了一个Lifecycle.START_EVENT事件时，调用了HostConfig的start方法，接下来，我们继续看start方法：</p>
<pre><code><span class="type">HostConfig</span>
public void start<span class="literal">()</span> {

    <span class="keyword">if</span> (log.isDebugEnabled<span class="literal">()</span>)
        log.debug(sm.getString(<span class="string">"hostConfig.start"</span>));

    <span class="keyword">try</span> {
        <span class="type">ObjectName</span> hostON = host.getObjectName<span class="literal">()</span>;
        oname = <span class="keyword">new</span> <span class="type">ObjectName</span>
            (hostON.getDomain<span class="literal">()</span> + <span class="string">":type=Deployer,host="</span> + host.getName<span class="literal">()</span>);
        <span class="type">Registry</span>.getRegistry(null, null).registerComponent
            (this, oname, this.getClass<span class="literal">()</span>.getName<span class="literal">()</span>);
    } catch (<span class="type">Exception</span> e) {
        log.error(sm.getString(<span class="string">"hostConfig.jmx.register"</span>, oname), e);
    }

    <span class="keyword">if</span> (host.getCreateDirs<span class="literal">()</span>) {
        <span class="type">File</span><span class="literal">[]</span> dirs = <span class="keyword">new</span> <span class="type">File</span><span class="literal">[]</span> {host.getAppBaseFile<span class="literal">()</span>,host.getConfigBaseFile<span class="literal">()</span>};
        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;dirs.length; i++) {
            <span class="keyword">if</span> (!dirs[i].mkdirs<span class="literal">()</span> &amp;&amp; !dirs[i].isDirectory<span class="literal">()</span>) {
                log.error(sm.getString(<span class="string">"hostConfig.createDirs"</span>,dirs[i]));
            }
        }
    }

    <span class="keyword">if</span> (!host.getAppBaseFile<span class="literal">()</span>.isDirectory<span class="literal">()</span>) {
        log.error(sm.getString(<span class="string">"hostConfig.appBase"</span>, host.getName<span class="literal">()</span>,
                host.getAppBaseFile<span class="literal">()</span>.getPath<span class="literal">()</span>));
        host.setDeployOnStartup(<span class="literal">false</span>);
        host.setAutoDeploy(<span class="literal">false</span>);
    }

    <span class="keyword">if</span> (host.getDeployOnStartup<span class="literal">()</span>)
        deployApps<span class="literal">()</span>;

}
</code></pre><p>start方法首先注册自己的mbean中，然后创建了一个目录，最后部署应用。</p>
<h3 id="4-3_部署应用程序">4.3 部署应用程序</h3><p>HostConfig的start方法做了很多事，前面的我们都不关心，我们只看deployApps方法：</p>
<pre><code><span class="function">HostConfig
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deployApps</span><span class="params">()</span> </span>{
    <span class="comment">//获取应用路径，即webapps目录</span>
    File appBase = host.getAppBaseFile();
    File configBase = host.getConfigBaseFile();
    String[] filteredAppPaths = filterAppPaths(appBase.<span class="built_in">list</span>());
    <span class="comment">// Deploy XML descriptors from configBase</span>
    deployDescriptors(configBase, configBase.<span class="built_in">list</span>());
    <span class="comment">// Deploy WARs</span>
    deployWARs(appBase, filteredAppPaths);
    <span class="comment">// Deploy expanded folders</span>
    deployDirectories(appBase, filteredAppPaths);
}
</code></pre><p>前面的跟具体功能相关，就不解析了，我们只看最后一段deployDirectories：</p>
<pre><code>    <span class="keyword">protected</span> <span class="keyword">void</span> deployDirectories(File appBase, <span class="keyword">String</span>[] files) {

    <span class="keyword">if</span> (files == <span class="keyword">null</span>)
        <span class="keyword">return</span>;

    ExecutorService es = host.getStartStopExecutor();
    List&lt;Future&lt;?&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();

    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) {

        <span class="keyword">if</span> (files[i].equalsIgnoreCase(<span class="string">"META-INF"</span>))
            <span class="keyword">continue</span>;
        <span class="keyword">if</span> (files[i].equalsIgnoreCase(<span class="string">"WEB-INF"</span>))
            <span class="keyword">continue</span>;
        File dir = <span class="keyword">new</span> File(appBase, files[i]);
        <span class="keyword">if</span> (dir.isDirectory()) {
            ContextName cn = <span class="keyword">new</span> ContextName(files[i], <span class="keyword">false</span>);

            <span class="keyword">if</span> (isServiced(cn.getName()) || deploymentExists(cn.getName()))
                <span class="keyword">continue</span>;

            results.<span class="built_in">add</span>(es.submit(<span class="keyword">new</span> DeployDirectory(<span class="keyword">this</span>, cn, dir)));
        }
    }

    <span class="keyword">for</span> (Future&lt;?&gt; result : results) {
        <span class="keyword">try</span> {
            result.<span class="built_in">get</span>();
        } <span class="keyword">catch</span> (Exception e) {
            <span class="built_in">log</span>.error(sm.getString(
                    <span class="string">"hostConfig.deployDir.threaded.error"</span>), e);
        }
    }
}
</code></pre><p>我们看到，这里获取到了webapps目录下的所有目录，然后使用线程池进行加载每个子目录。</p>
<h3 id="4-4_DeployDirectory内部实现">4.4 DeployDirectory内部实现</h3><p>由于使用的是线程池，我们看它的run方法：</p>
<pre><code>DeployDirectory
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    config.deployDirectory(cn, dir);
}
</code></pre><p>返回来调用了HostConfig的deployDirectory方法，我们继续跟踪：</p>
<pre><code>HostConfig
<span class="keyword">protected</span> <span class="keyword">void</span> deployDirectory(ContextName cn, <span class="keyword">File</span> dir) {

    Context context = <span class="keyword">null</span>;
    <span class="keyword">File</span> xml = <span class="keyword">new</span> <span class="keyword">File</span>(dir, Constants.ApplicationContextXml);
    <span class="keyword">File</span> xmlCopy =
            <span class="keyword">new</span> <span class="keyword">File</span>(host.getConfigBaseFile(), cn.getBaseName() + <span class="string">".xml"</span>);

    DeployedApplication deployedApp;
    <span class="keyword">boolean</span> copyThisXml = copyXML;
    <span class="comment">//获取web.xml文件，并创建一个Context</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> (deployXML &amp;&amp; xml.exists()) {
            <span class="keyword">synchronized</span> (digesterLock) {
                <span class="keyword">try</span> {
                    context = (Context) digester.parse(xml);
                } <span class="keyword">catch</span> (Exception e) {
                    context = <span class="keyword">new</span> FailedContext();
                } <span class="keyword">finally</span> {
                    <span class="keyword">if</span> (context == <span class="keyword">null</span>) {
                        context = <span class="keyword">new</span> FailedContext();
                    }
                    digester.reset();
                }
            }

            ...<span class="comment">//略</span>
        } 
         ....<span class="comment">//略</span>
        <span class="comment">//加载ContextConfig并实例化    </span>
        <span class="keyword">Class</span>&lt;?&gt; clazz = <span class="keyword">Class</span>.forName(host.getConfigClass());
        LifecycleListener listener =
            (LifecycleListener) clazz.newInstance();
        context.addLifecycleListener(listener);

        context.setName(cn.getName());
        context.setPath(cn.getPath());
        context.setWebappVersion(cn.getVersion());
        context.setDocBase(cn.getBaseName());
        <span class="comment">//将Context添加到host中。</span>
        host.addChild(context);
    } <span class="keyword">catch</span> (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(sm.getString(<span class="string">"hostConfig.deployDir.error"</span>,
                dir.getAbsolutePath()), t);
    } <span class="keyword">finally</span> {
        ...<span class="comment">//略</span>
}
</code></pre><p>在这里，我们发现，创建了一个Context，并将其添加到Host中，就完成了未在server.xml中配置Context也可以启动webapps目录下的工程了。好的，container启动部分就到此结束了，下文将介绍connector启动部分。</p>
<h2 id="五，流程图">五，流程图</h2><p><img src="/img/2015/tomcat8-catalian-start1.png" alt=""><br><img src="/img/2015/tomcat8-catalian-start2.png" alt=""><br><img src="/img/2015/tomcat8-catalian-start3.png" alt=""></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/15/2015/redis-study/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          redis学习
        
      </div>
    </a>
  
  
    <a href="/2015/08/12/2015/tomcat8-sourcecode03/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">tomcat8源码阅读(三)--启动二</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2015/tomcat8-sourcecode04" data-title="tomcat8源码阅读(四)--启动三" data-url="http://sqtds.github.io/2015/08/12/2015/tomcat8-sourcecode04/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"sqtds"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>



</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 sqtds
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>